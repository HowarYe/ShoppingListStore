<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Arial" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308273 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Arial;
      font-size: 11pt;
    }
  </style>
</head>
<body>
<a name="1206"/>

<div>
<span><div><span style="font-size: 12pt;">Process:</span>  <a href="https://elixir-lang.org/getting-started/processes.html">https://elixir-lang.org/getting-started/processes.html</a></div><div>• A language construct for executing code asynchronously and in isolation</div><div>• Fundamental unit of concurrency in Elixir </div><div>• <span style="font-weight: bold; text-decoration: underline;">Not</span> an OS process </div><div>• Very lightweight </div><div>• Can be spawned or destroyed within microseconds</div><div><br/></div><div>PID</div><div>• First number represents the node </div><div>    • 0 is always the local node </div><div>    • A node could be a different computer, or just another instance of BEAM running on the same computer</div><div>• Second and third numbers comprise the process number on that node</div><div>e.g.  #PID&lt;0.105.0&gt; </div><div><br/></div><div>self/0 ; self(): return the PID of the calling process</div><div><br/></div><div>spawn/1 : </div><div>• Spawns a new process, executing the anonymous function passed to it </div><div>• The process exits as soon as the function is done executing </div><div>• spawn is low-level and we don't usually call it directly</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; pid = spawn(fn -&gt; IO.puts(&quot;Hi&quot;) end)</div><div>Hi</div><div>#PID&lt;0.130.0&gt;</div><div>iex&gt; Process.alive?(pid)</div><div>false</div></div><div>spawn/3 : </div><div>Parameters</div><div>• Module name</div><div>• Function name (atom)</div><div>• List of arguments</div><div>(person.ex)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>defmodule Person do</div><div>    def greet(name) do</div><div>        IO.puts(&quot;Hi #{name} from&quot;)</div><div>        IO.puts(&quot;#{inspect self()}&quot;)</div><div>    end</div><div>end</div></div><div>iex</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; pid = spawn(Person, :greet, [&quot;Joe&quot;])</div><div>Hi Joe</div><div>from #PID&lt;0.220.0&gt;</div></div><div><br/></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Linking Processes</span></font></div><div>• Processes can spawn other processes, forming arbitrarily complex process hierarchies.  Normally, a process will not know about the termination of one of its child processes unless it actively checks for it</div><div>However, for link_processes</div><div>• We can link a parent process to its child process using the spawn_link/1 or spawn_link/3 functions</div><div style="margin-left: 40px;">• When two processes are linked and one exits with a signal other than :normal the other will receive the signal and exit with the same reason</div><div style="margin-left: 40px;">• Links are bidirectional. A process that dies will send its exit reason to its parent and any children</div><div>• To avoid being killed when its child process dies, a process can trap exit signals</div><div>• In this case, the process will receive a message when its child process dies, instead of exiting</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; self()</div><div>#PID&lt;0.230.0&gt;</div><div>iex&gt; pid = spawn_link(fn -&gt; receive do; end; end)</div><div>#PID&lt;0.233.0&gt;</div><div>iex&gt; Process.flag(:trap_exit, true)</div><div>false</div><div>iex&gt; Process.exit(pid, :quit)</div><div>true</div><div>iex&gt; flush</div><div>{:EXIT, #PID&lt;0.233.0&gt;, :quit}</div><div>iex&gt; self()</div><div>#PID&lt;0.230.0&gt;</div></div><div><br/></div><div>Process.monitor/1</div><div>set up a unidirectional link between the monitoring process and the process to be monitored</div><div><br/></div><div><br/></div><div><b><font style="font-size: 12pt;">Node</font></b></div><div>• All code that we execute in Elixir / Erlang is executed on a node </div><div><span>    </span>• This is a fancy name for a running instance of the Erlang VM (BEAM)</div><div>• A node is akin to a mini operating system running on top of your host OS, providing:</div><div><span>    </span> • Event handling </div><div><span>    </span>• Process scheduling </div><div><span>    </span>• Memory allocation and reclamation (garbage collection) </div><div><span>    </span>• Naming services </div><div><span>    </span>• Interprocess communication (IPC)<br/></div><div>• A node can connect to other nodes to provide many of these services to remote nodes on </div><div><span>    </span>• The same computer </div><div><span>    </span>• Another computer on the local network </div><div><span>    </span>• Another computer on the Internet</div><div>• Each node has a name, by which other nodes reference it</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; Node.self() </div><div>:nonode@nohost</div></div><div>• We can set the name of our node when starting Elixir </div><div><span>    </span>• This works both with iex and with the elixir and elixirc commands</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># in cmd line</div><div>iex --name node1@127.0.0.1 </div><div>Interactive Elixir (1.8.1) - press Ctrl+C to exit </div><div># in iex</div><div>iex(node1@127.0.0.1)&gt; Node.self() </div><div>:&quot;node1@127.0.0.1&quot;</div></div><div><br/></div><div>• Process naming is accomplished using Process.register/2</div><div><span>    </span>• PID </div><div><span>    </span>• Name (atom)<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>node2&gt; pid = spawn(wait_for_hi)</div><div>#PID&lt;0.126.0&gt;</div><div>node2&gt; Process.register(pid, :greeter)</div><div>true</div><div>node2&gt; Process.whereis(:greeter)</div><div>#PID&lt;0.126.0&gt;</div><div>node2&gt; send(:greeter, :hi)</div><div>Someone said hi</div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 