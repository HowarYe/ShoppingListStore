<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Arial" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308273 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Arial;
      font-size: 11pt;
    }
  </style>
</head>
<body>
<a name="1202"/>

<div>
<span><div>first of all: iex --- same as irb for Ruby</div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">1.Introduction</span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-style: italic;">Elixir: share nothing concurrency model</span></font></div><div style="margin-left: 40px;">• In Elixir, code runs in lightweight processes</div><div style="margin-left: 40px;">• No shared state -- processes <span style="text-decoration: underline;">modify only their own private state</span></div><div style="margin-left: 40px;">• Processes communicate via message passing</div><div style="margin-left: 40px;">• Each process has a mailbox (message queue) where incoming messages wait until they are processed one at a time</div><div style="margin-left: 40px;">• In this model, race condition is rare</div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-style: italic;">Elixir code uses two file extensions: </span></font></div><div style="margin-left: 40px;">• .ex files are meant to be compiled </div><div style="margin-left: 40px;">• .exs files are meant to be for scripting</div><div><br/></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-style: italic;">Different  between elixir &amp; elixirc (cmd): 对应 .ex 跟 .exs</span></font></div><div>• Compile and run (writes bytecode to disk)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#in cmd # there is some elixir code in hello.ex</div><div># elixirc hello.ex # commend in cmd</div><div>Hello, world! </div><div># ls # commend in cmd</div><div>Elixir.Hello.beam hello.ex</div></div><div>• Compile on the fly and run (does not write bytecode to disk)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># elixir hello.exs </div><div>Hello, world! </div><div># ls </div><div>hello.exs</div></div><div><br/></div><div>under iex:</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># compile and run</div><div>c &quot;name.ex&quot;</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; clear # Clear the screen </div><div>iex&gt; ls # List current directory </div><div>iex&gt; (Ctrl+C twice) # Exit</div></div><div><br/></div><div>number:</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; 10 / 2 # Floating-point division 5.0 </div><div>iex&gt; div(10, 2) # Integer division 5 </div><div>iex&gt; rem(10, 3) # Remainder (10 % 3) 1</div></div><div><br/></div><div><br/></div><div>Atoms:</div><div>• Atoms are constants, whose names are their own values </div><div>• They are akin to symbols in Ruby</div><div>• Atoms with spaces or special characters can be put in double quotes</div><div>Boolean:</div><div>true and false are really just references to the atoms :true and :false</div><div>• and, or, and not operators should be used with Boolean operands </div><div>• Use &amp;&amp;, ||, and ! when <span style="text-decoration: underline;">working with other types </span></div><div>• Note: as in Ruby, 0 is <span style="font-weight: bold; text-decoration: underline;">not</span> equal to false</div><div><br/></div><div>Unlike Ruby, Elixir distinguishes between double and single quotes </div><div>• &quot; – String (<span style="font-weight: bold; text-decoration: underline;">binary</span>)</div><div>• ' – <span style="font-weight: bold; text-decoration: underline;">List</span> of characters</div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">List</span>:</div><div>• can be mixed type list [1,true,2,3]</div><div>• lists are implemented as linked lists</div><div>• Concatenation and subtraction operators exist e.g.:</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>[1,2,3] ++ [4,5,6] == [1,2,3,4,5,6]</div><div>[1,2,3] -- [2,3] == [1]</div><div>hd [1,2,3] == 1</div><div>tl [1,2,3] [2, 3]</div></div><div><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">•</span><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">  </span>As in Haskell, the hd and tl functions return the head and tail of a list, respectively</div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">Anonymous Function: </span></div><div>• <span style="font-size: 11pt;">similar to lambdas func. in ruby and haskell</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; greet = fn (name) -&gt; &quot;Hello, #{name}&quot; end </div><div>#Function&lt;6.99386804/1 in :erl_eval.expr/5&gt; </div><div>iex&gt; greet.(&quot;Jeff&quot;) </div><div>&quot;Hello, Jeff&quot;</div></div><div>• Parentheses around the parameters are optional</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; sum = fn a, b -&gt; a + b end </div><div>#Function&lt;12.99386804/2 in :erl_eval.expr/5&gt; </div><div>iex&gt; sum.(4,5) </div><div>9</div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">Elixir Operators</span></div><div><img src="Self Study Note 1_files/Image.png" type="image/png" data-filename="Image.png" width="496"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; &quot;Hello, &quot; &lt;&gt; &quot;World&quot; </div><div>&quot;Hello, World&quot;</div></div><div>== Equality </div><div>=== Strict equality  (must be totally the same e.g.（1 === 1.0 false）)</div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">tuple {} list []</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Pattern Matching</span></div><div><span style="font-weight: bold;">• = is the match operator; do not think assignment when you see =</span></div><div>• Use _ to match any value (This is used when we want to match a value in a pattern, but we don't care about the value)</div><div>• ^ is the pin operator (Use this to match against a variable's value, rather than rebinding it)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; x = 1 </div><div>1 </div><div>iex&gt; [^x, y, z] = [1,2,3] </div><div>[1, 2, 3] </div><div>iex&gt; [^x, y, z] = [9,2,3] </div><div>** (MatchError) no match of right hand side value: [9, 2, 3]</div></div><div><br/></div><div>Read a file using pattern matching and anonymous function: (e.g.)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; read_file = fn filename -&gt; </div><div>    case File.read(filename) do</div><div>        {:ok, contents} -&gt; contents </div><div>        {:error, _} -&gt; IO.puts &quot;Can't read #{filename}&quot; </div><div>    end </div><div>end </div><div>iex&gt; read_file.(&quot;hello.txt&quot;) </div><div>&quot;Hello\n&quot; </div><div>iex&gt; read_file.(&quot;file.txt&quot;) </div><div>Can't read file.txt</div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Keyword lists: (hash table/ map/ dictionary)</span></div><div>• We frequently use a list of 2-tuples in functional programming as a key-value store</div><div>• Elixir provides syntactic sugar for such lists:</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; p1 = [{:name, &quot;Joe&quot;}, {:age, 51}] </div><div>[name: &quot;Joe&quot;, age: 51] </div><div>iex&gt; p2 = [name: &quot;Joe&quot;, age: 51] </div><div>[name: &quot;Joe&quot;, age: 51] </div><div>iex&gt; p1 == p2 </div><div>true</div></div><div>take a look at: Enum.join</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>h Enum.join</div></div><div>• Keyword lists are often used to pass options to functions</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; car_listing = </div><div>    fn (price, opts) -&gt; </div><div>        options = Enum.join(Keyword.values(opts), &quot;, &quot;) </div><div>        IO.puts(&quot;Price: $#{price}&quot;) </div><div>        IO.puts(&quot;Options: #{options}&quot;) </div><div>    end </div><div><br/></div><div>iex&gt; car_listing.(45000, [colour: &quot;red&quot;, trans: &quot;auto&quot;]) </div><div>Price: $45000 Options: red, auto</div></div><div>• if in Elixir is simply a macro that takes a keyword list. All are equivalent:</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>if rem(x, 2) == 0, do: &quot;Even&quot;, else: &quot;Odd&quot; </div><div>if(rem(x, 2) == 0, [do: &quot;Even&quot;, else: &quot;Odd&quot;])</div><div>if(rem(x, 2) == 0, [{:do, &quot;Even&quot;}, {:else, &quot;Odd&quot;}])</div></div><div>• We can access individual values using Keyword.get (Elixir provides syntactic sugar for this, too)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; p1 = [name: &quot;Joe&quot;, age: 51, type: &quot;employee&quot;] </div><div>[name: &quot;Joe&quot;, age: 51, type: &quot;employee&quot;]</div><div><br/></div><div>Keyword.get(p1, :age) === p1[:age]</div></div><div>• it's important to remember they're lists, and list access is slow</div><div>    If you need a large list of keyvalue pairs, use a map instead</div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Map</span></div><div>• Elixir provides a map data structure: a fast, unordered dictionary type</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># =&gt; Hash rocket syntax; works with any type of key</div><div>map1 = %{:a =&gt; 1, :b =&gt; 2}</div><div>map2 = %{&quot;name&quot; =&gt; &quot;Joe&quot;, &quot;age&quot; =&gt; 51}</div><div># Can use this syntax when keys are atoms</div><div>map3 = %{a: 1, b: 2}</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"># 1 &amp; 3 are eq， 2 key's name is String</span></div></div><div>• Three ways to access values: </div><div style="margin-left: 40px;">• Map.get(map,key) </div><div style="margin-left: 40px;">    Works with any key type </div><div style="margin-left: 40px;">• map[key] </div><div style="margin-left: 40px;">    Works with any key type </div><div style="margin-left: 40px;">• map.key </div><div style="margin-left: 40px;">    Only works when keys are atoms</div><div>• Use | to update an existing value in a map, but <span style="font-weight: bold; font-size: 12pt;">remember:</span> types in Elixir are immutable. This returns a new map (which means original map remains the same</div><div style="margin-left: 40px;">• Updating a nonexistent key is an error</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>map = %{a: 1, b: 2}</div><div>map2 = %{map | b: 99}</div></div><div>• Pattern matching works with maps, and will match if the keys on the LHS are a subset of the keys on the RHS</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; %{a: x} = %{a: 1, b: 2}</div><div> %{a: 1, b: 2} </div><div>iex&gt; x </div><div>1</div></div><div>• This is more flexible than with keyword lists, where every key in the list must appear on the LHS</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; [a: x, b: y] = [a: 1, b: 2] </div><div>[a: 1, b: 2] </div><div>iex&gt; x </div><div>1 </div><div>iex&gt; y </div><div>2 </div><div>iex&gt; [a: x] = [a: 1, b: 2] </div><div>** (MatchError) no match of right hand side value: [a: 1, b: 2]</div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">Struct</span></div><div>• Structs are an extension of maps, allowing us to specify: </div><div style="margin-left: 40px;">• Keys that are allowed </div><div style="margin-left: 40px;">• Keys that are required </div><div style="margin-left: 40px;">• Default values for any keys</div><div>• Elixir will then perform compile-time checks to ensure that the keys given are valid for any struct created</div><div>• Structs are defined within a module using the <span style="font-weight: bold;">defstruct</span> keyword, and take the name of the module in which they are defined</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>defmodule Student do </div><div>    defstruct [:name, :number, :type] </div><div>end</div></div><div>• We can specify required keys using the <span style="font-weight: bold;">enforce_keys</span> module attribute (more later), and/or specify default values for keys, if desired (:type here)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>defmodule Student do </div><div>    @enforce_keys [:name, :number] </div><div>    defstruct [:name, :number, type: &quot;ugrad&quot;]</div><div>end</div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">Module</span></div><div>• Modules are used to group related functions and are defined with the <span style="font-weight: bold;">defmodule</span> macro </div><div>• Public functions are defined with the <span style="font-weight: bold;">def</span> macro </div><div>• Private functions are defined with the <span style="font-weight: bold;">defp</span> macro</div><div>e.g. (person.ex)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>defmodule Person do </div><div><br/></div><div>    def new(fname, lname, age) do </div><div>        %{fn: fname, ln: lname, age: age} </div><div>    end </div><div><br/></div><div>    def greet(person) do </div><div>        IO.puts(&quot;Hi, #{full_name(person)}&quot;) </div><div>    end </div><div><br/></div><div>    defp full_name(person) do</div><div>        person.fn &lt;&gt; &quot; &quot; &lt;&gt; person.ln </div><div>    end </div><div><br/></div><div>end</div></div><div>• All modules are submodules of the Elixir module</div><div>• We can further nest modules for organization and modularity</div><div>(hello.ex)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>defmodule A do</div><div>    defmodule B do</div><div>        def C do </div><div>            IO.puts &quot;Hello&quot;</div><div>        end</div><div>    end</div><div>end</div></div><div>is equal to </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>defmodule A.B do</div><div>    def C do</div><div>        IO.puts &quot;Hello&quot;</div><div>    end </div><div>end</div></div><div><br/></div><div><span style="font-weight: bold;">• Conventions</span></div><div>    • One module per file </div><div>    • Module names should be <span style="font-weight: bold;">CamelCased </span></div><div>    • Filenames should be <span style="font-weight: bold;">snake_cased </span></div><div>    • Function and variable names should be <span style="font-weight: bold;">snake_cased</span></div><div>• When we compile a module with elixirc, it is compiled to byte code and written to a .beam file</div><div>• iex will automatically load all .beam files in the current directory</div><div><br/></div><div>• Alternatively, we can compile a module using the c() function in iex </div><div>• To reload a module, pass the module name to the r() function</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; c &quot;hello.ex&quot; </div><div>[A, B.C]</div><div>iex&gt; A.B.C() </div><div>Hello</div><div>iex&gt; r(A.B) </div><div>{:reloaded, A.B, [A.B, A]}</div></div><div><br/></div><div>• Modules can have <span style="font-weight: bold;">attributes</span>, which are used in practice as we would use constants in other languages</div><div>    • Functions within a module can access its attributes</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>defmodule A.B do </div><div>    @greeting &quot;Hello, world&quot; </div><div>    def C do </div><div>        IO.puts @greeting </div><div>    end </div><div>end</div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">Function</span></div><div>• (Named) functions must be defined within modules </div><div>• Multi-line functions are defined within <span style="text-decoration: underline;">do...end blocks </span></div><div>• Single-line functions are defined using <span style="text-decoration: underline;">do: </span></div><div>• As in Ruby, the return value of a function is simply <span style="text-decoration: underline;">the result of its last expression</span> </div><div>    • Elixir has no return keyword</div><div>(math_helpers.ex)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>defmodule MathHelpers do </div><div>    def sum(x,y) do </div><div>        x + y </div><div>    end </div><div>    def diff(x,y), do: x – y </div><div>end</div></div><div><br/></div><div>Arity</div><div>• A function's arity is the number of arguments it takes</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>defmodule MathHelpers do </div><div>    def sum_of(a,b), do: a + b </div><div>    def sum_of(a,b,c), do: a + b + c </div><div>    def negate(a), do: -a </div><div>end</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; MathHelpers.&lt;TAB&gt; #or A.B&lt;TAB&gt; &lt;TAB&gt; means type Tab on ur keyboard</div><div>negate/1 sum_of/2 sum_of/3</div></div><div><br/></div><div>Clause</div><div>• Functions can have multiple clauses</div><div>    • These look like multiple function definitions, but they are really multiple clauses of the same definition</div><div>• Elixir uses pattern matching from top to bottom to determine which to invoke</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>defmodule Factorial do </div><div>    def of(0), do: 1 </div><div>    def of(n), do: n * of(n-1) </div><div>end</div></div><div>• Our factorial function has a problem: what happens if we pass a negative number?</div><div>• To guard against this, we use guard clauses </div><div>    • Only a subset of Elixir expressions are supported in guards </div><div>    • See <a href="https://hexdocs.pm/elixir/guards.html">https://hexdocs.pm/elixir/guards.html</a></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>defmodule Factorial do </div><div>    def of(0), do: 1 </div><div>    def of(n) when is_integer(n) and n &gt; 0 do </div><div>        n * of(n-1) </div><div>    end </div><div>end</div></div><div><br/></div><div>Default Parameter</div><div>• We can specify default values for function parameters using the syntax </div><div>    <span style="text-decoration: underline;">param \\ value</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>defmodule Person do </div><div>    def new(name, type \\ &quot;student&quot;) </div><div>        do %{name: name, type: type} </div><div>    end </div><div>end</div></div><div>• Behind the scenes, this is really creating three function clauses:</div><div>    • func/2, taking p1 and p4 as parameters </div><div>    • func/3, taking p1, p2, and p4 as parameters</div><div>    • func/4, taking p1, p2, p3, and p4 as parameters</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>defmodule Example do</div><div>    def func(p1, p2 \\ 2, p3 \\ 3, p4) do</div><div>        IO.inspect [p1, p2, p3, p4]</div><div>    end</div><div>end</div></div><div>here's the way to do default para:</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>defmodule DefaultParams3 do</div><div>    def greet(name, type \\ &quot;student&quot;)</div><div>    </div><div>    def greet(name, &quot;employee&quot;) do</div><div>        IO.puts(&quot;Hello employee with name #{name}&quot;)</div><div>    end</div><div><br/></div><div>    def greet(name, type) do</div><div>        IO.puts(&quot;Hello #{type} #{name}&quot;)</div><div>    end</div><div>end</div></div><div><br/></div><div><span style="font-weight: bold;">Pipe Operator:</span></div><div>• Consider some code like the following, where we have a chain of functions invoked, with the return value of one function being passed to the next</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>filing = prepare_filing(</div><div>    sales_tax(</div><div>        Orders.for_customers(DB.find_customers),</div><div>        2018</div><div>        )</div><div>    )    </div></div><div>• To make this more readable, we might do something like the following:</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>people = DB.find_customers</div><div>orders = Orders.for_customers(people)</div><div>tax = sales_tax(orders, 2018)</div><div>filing = prepare_filing(tax)</div></div><div>• Elixir provides a better way to chain function calls like this using the <span style="font-weight: bold;">pipe operator: |&gt; </span></div><div>• This takes the result of the LHS and inserts it as the first parameter of the function invocation on the RHS </div><div>• val |&gt; f(a,b) === f(val, a, b)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>filing = DB.find_customers</div><div>    |&gt; Orders.for_customers</div><div>    |&gt; sales_tax(2018)</div><div>    |&gt; prepare_filing</div></div><div><br/></div><div><br/></div><div><font style="font-size: 12pt;">Recursion</font></div><div>• Like Haskell, Elixir performs tail call optimization </div><div>• If we write our recursive algorithms to take advantage of this, we avoid creating additional stack frames for each recursive call</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>defmodule ListHelpers do</div><div>    def len([], acc), do: acc</div><div>    def len([_head | tail], acc) do</div><div>        len(tail, acc + 1)</div><div>    end</div><div>    def len(list) when is_list(list) do</div><div>        len(list, 0)</div><div>    end</div><div>end</div></div><div><br/></div><div><br/></div><div><font style="font-size: 12pt;">Control Flow</font></div><div>if</div><div>unless</div><div>cond</div><div>• The cond macro allows us to check multiple conditions and find the first one that evaluates to true </div><div>• If none returns true, a CondClauseError is raised</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>iex&gt; price = cond do</div><div>...&gt;     type == &quot;child&quot; -&gt;</div><div>...&gt;         9.99</div><div>...&gt;     type == &quot;student&quot; -&gt;</div><div>...&gt;         11.99</div><div>...&gt;     true -&gt;</div><div>...&gt;         15.99</div><div>...&gt; end</div></div><div>case</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html>
